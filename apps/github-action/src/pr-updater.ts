import type { Octokit } from "@octokit/rest";

export interface UpdateOptions {
  owner: string;
  repo: string;
  pullNumber: number;
  summary: string;
  existingBody: string;
  riskLevel: string;
  impactScore: number;
  checklist?: string[];
  ghostCommits?: Array<{ sha: string; message: string; detected: boolean; reason?: string }>;
  prTitle?: string;
  prAuthor?: string;
}

const LAZYPR_SECTION_START = "<!-- LAZYPR_SUMMARY_START -->";
const LAZYPR_SECTION_END = "<!-- LAZYPR_SUMMARY_END -->";
const FOOTER_PATTERN = /\n---\n\*Generated by lazypr.*\*/;

export async function updatePRDescription(octokit: Octokit, options: UpdateOptions): Promise<void> {
  const {
    owner,
    repo,
    pullNumber,
    summary,
    existingBody,
    riskLevel,
    impactScore,
    checklist,
    ghostCommits,
    prTitle,
    prAuthor,
  } = options;

  const lazyprSection = buildLazyprSection({
    summary,
    riskLevel,
    impactScore,
    checklist,
    ghostCommits,
    prTitle,
    prAuthor,
  });

  const cleanedBody = removeExistingLazyprSection(existingBody);

  const newBody = `${cleanedBody.trim()}\n\n${lazyprSection}`.trim();

  try {
    await octokit.pulls.update({
      owner,
      repo,
      pull_number: pullNumber,
      body: newBody,
    });
  } catch (error) {
    console.warn(`Warning: Failed to update PR description: ${error}`);
    throw error;
  }
}

interface LazyprSectionOptions {
  summary: string;
  riskLevel: string;
  impactScore: number;
  checklist?: string[];
  ghostCommits?: Array<{ sha: string; message: string; detected: boolean; reason?: string }>;
  prTitle?: string;
  prAuthor?: string;
}

function buildLazyprSection(options: LazyprSectionOptions): string {
  const { summary, riskLevel, impactScore, checklist, ghostCommits, prTitle, prAuthor } = options;

  const timestamp = new Date().toISOString();
  const prUrlBase = "https://github.com/owner/repo/pull/123";
  const prUrl = prUrlBase.replace("owner/repo/123", "owner/repo/pull/123");

  const riskEmoji = riskLevel === "HIGH" ? "üî¥" : riskLevel === "MEDIUM" ? "üü°" : "üü¢";

  const titlePart = prTitle ? ": " + prTitle : "";
  const section =
    LAZYPR_SECTION_START +
    "\n## üöÄ PR Summary" +
    titlePart +
    "\n\n" +
    summary +
    "\n\n### üìä Risk Assessment: " +
    riskEmoji +
    " " +
    riskLevel +
    " (Score: " +
    String(impactScore) +
    "/100)\n\n---\n*Generated by lazypr at " +
    timestamp +
    "*\n*View changes: " +
    prUrl +
    "*" +
    LAZYPR_SECTION_END;

  return section;
}

function removeExistingLazyprSection(body: string): string {
  if (!body) {
    return "";
  }

  const startIndex = body.indexOf(LAZYPR_SECTION_START);
  if (startIndex === -1) {
    return body.replace(FOOTER_PATTERN, "").trim();
  }

  const endIndex = body.indexOf(LAZYPR_SECTION_END, startIndex);
  if (endIndex === -1) {
    return body.substring(0, startIndex).trim();
  }

  const beforeSection = body.substring(0, startIndex).trim();
  const afterSection = body.substring(endIndex + LAZYPR_SECTION_END.length);

  const combined = `${beforeSection} ${afterSection}`.trim();

  return combined.replace(FOOTER_PATTERN, "").trim();
}

export async function getCurrentPRBody(
  octokit: Octokit,
  owner: string,
  repo: string,
  pullNumber: number,
): Promise<string> {
  try {
    const response = await octokit.pulls.get({
      owner,
      repo,
      pull_number: pullNumber,
    });
    return response.data.body ?? "";
  } catch (error) {
    console.warn(`Warning: Failed to get PR body: ${error}`);
    return "";
  }
}

export function formatChecklistForMarkdown(checklist: string[]): string {
  if (!checklist || checklist.length === 0) {
    return "";
  }

  const lines = ["### Reviewer Checklist"];

  for (const item of checklist) {
    lines.push(`- [ ] ${item}`);
  }

  return lines.join("\n");
}

export function formatGhostCommitsForMarkdown(
  ghostCommits: Array<{ sha: string; message: string; detected: boolean; reason?: string }>,
): string {
  if (!ghostCommits || ghostCommits.length === 0) {
    return "";
  }

  const detected = ghostCommits.filter((c) => c.detected);

  if (detected.length === 0) {
    return "";
  }

  const lines = ["### ‚ö†Ô∏è Potential Ghost Commits Detected"];

  for (const commit of detected) {
    const sha = commit.sha.substring(0, 7);
    const reason = commit.reason ?? "Commit message may not match changes";
    lines.push(`- **${sha}**: ${reason}`);
  }

  return lines.join("\n");
}
