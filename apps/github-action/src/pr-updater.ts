import * as core from "@actions/core";
import type { OctokitClient } from "./octokit-types.js";

export interface UpdateOptions {
  owner: string;
  repo: string;
  pullNumber: number;
  summary: string;
  existingBody: string;
  riskLevel: string;
  impactScore: number;
  checklist?: string[];
  ghostCommits?: Array<{ sha: string; message: string; detected: boolean; reason?: string }>;
  prTitle?: string;
  prAuthor?: string;
}

const LAZYPR_SECTION_START = "<!-- LAZYPR_SUMMARY_START -->";
const LAZYPR_SECTION_END = "<!-- LAZYPR_SUMMARY_END -->";
const FOOTER_PATTERN = /\n---\n\*Generated by lazypr.*\*/;

export async function updatePRDescription(
  octokit: OctokitClient,
  options: UpdateOptions,
): Promise<void> {
  const {
    owner,
    repo,
    pullNumber,
    summary,
    existingBody,
    riskLevel,
    impactScore,
    checklist,
    ghostCommits,
    prTitle,
    prAuthor,
  } = options;

  const lazyprSection = buildLazyprSection({
    owner,
    repo,
    pullNumber,
    summary,
    riskLevel,
    impactScore,
    checklist,
    ghostCommits,
    prTitle,
    prAuthor,
  });

  const cleanedBody = removeExistingLazyprSection(existingBody);

  const newBody = `${cleanedBody.trim()}\n\n${lazyprSection}`.trim();

  try {
    await octokit.rest.pulls.update({
      owner,
      repo,
      pull_number: pullNumber,
      body: newBody,
    });
  } catch (error) {
    core.warning(`Failed to update PR description: ${error}`);
    throw error;
  }
}

interface LazyprSectionOptions {
  owner: string;
  repo: string;
  pullNumber: number;
  summary: string;
  riskLevel: string;
  impactScore: number;
  checklist?: string[];
  ghostCommits?: Array<{ sha: string; message: string; detected: boolean; reason?: string }>;
  prTitle?: string;
  prAuthor?: string;
}

function buildLazyprSection(options: LazyprSectionOptions): string {
  const { owner, repo, pullNumber, summary, riskLevel, impactScore, prTitle, prAuthor } = options;

  const timestamp = new Date().toISOString();
  const prUrl = `https://github.com/${owner}/${repo}/pull/${String(pullNumber)}`;

  const riskEmoji = riskLevel === "HIGH" ? "üî¥" : riskLevel === "MEDIUM" ? "üü°" : "üü¢";

  const titlePart = prTitle ? `: ${prTitle}` : "";
  const authorLine = prAuthor ? `**Author:** @${prAuthor}` : "";

  const checklistSection = options.checklist?.length
    ? `\n\n${formatChecklistForMarkdown(options.checklist)}`
    : "";

  const ghostCommitsMarkdown = options.ghostCommits
    ? formatGhostCommitsForMarkdown(options.ghostCommits)
    : "";
  const ghostCommitsSection = ghostCommitsMarkdown ? `\n\n${ghostCommitsMarkdown}` : "";

  const section = `${LAZYPR_SECTION_START}
## üöÄ PR Summary${titlePart}

${authorLine}

${summary.trim()}

### üìä Risk Assessment: ${riskEmoji} ${riskLevel} (Score: ${String(impactScore)}/100)${checklistSection}${ghostCommitsSection}

---
*Generated by lazypr at ${timestamp}*
*View changes: ${prUrl}*
${LAZYPR_SECTION_END}`;

  return section;
}

function removeExistingLazyprSection(body: string): string {
  if (!body) {
    return "";
  }

  const startIndex = body.indexOf(LAZYPR_SECTION_START);
  if (startIndex === -1) {
    return body.replace(FOOTER_PATTERN, "").trim();
  }

  const endIndex = body.indexOf(LAZYPR_SECTION_END, startIndex);
  if (endIndex === -1) {
    return body.substring(0, startIndex).trim();
  }

  const beforeSection = body.substring(0, startIndex).trim();
  const afterSection = body.substring(endIndex + LAZYPR_SECTION_END.length);

  const combined = `${beforeSection}\n\n${afterSection}`.trim();

  return combined.replace(FOOTER_PATTERN, "").trim();
}

export async function getCurrentPRBody(
  octokit: OctokitClient,
  owner: string,
  repo: string,
  pullNumber: number,
): Promise<string> {
  try {
    const response = await octokit.rest.pulls.get({
      owner,
      repo,
      pull_number: pullNumber,
    });
    return response.data.body ?? "";
  } catch (error) {
    core.warning(`Failed to get PR body: ${error}`);
    return "";
  }
}

export function formatChecklistForMarkdown(checklist: string[]): string {
  if (!checklist || checklist.length === 0) {
    return "";
  }

  const lines = ["### Reviewer Checklist"];

  for (const item of checklist) {
    lines.push(`- [ ] ${item}`);
  }

  return lines.join("\n");
}

export function formatGhostCommitsForMarkdown(
  ghostCommits: Array<{ sha: string; message: string; detected: boolean; reason?: string }>,
): string {
  if (!ghostCommits || ghostCommits.length === 0) {
    return "";
  }

  const detected = ghostCommits.filter((c) => c.detected);

  if (detected.length === 0) {
    return "";
  }

  const lines = ["### ‚ö†Ô∏è Potential Ghost Commits Detected"];

  for (const commit of detected) {
    const sha = commit.sha.substring(0, 7);
    const reason = commit.reason ?? "Commit message may not match changes";
    lines.push(`- **${sha}**: ${reason}`);
  }

  return lines.join("\n");
}
